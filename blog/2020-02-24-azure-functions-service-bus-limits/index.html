<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="map[]"><title>Límites en azure functions para procesos de larga duración</title><meta name=generator content="Hugo 0.68.3"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet type=text/css href=https://adrianabreu.github.io/css/main.css><link rel=stylesheet type=text/css href=https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700,800" rel=stylesheet><!--[if lt IE 9]><script src=https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js></script><script src=https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js></script><![endif]--></head><body><div id=wrap><nav class="navbar navbar-default"><div class=container><div class=navbar-header><a class=navbar-brand href=https://adrianabreu.github.io><i class="fa fa-home"></i></a></div><div id=navbar><ul class="nav navbar-nav navbar-right"><li><a href=/>INICIO</a></li><li><a href=/blog/>BLOG</a></li><li><a href=/knowledge/>KNOWLEDGE</a></li><li><a href=/archive/>ARCHIVE</a></li></ul></div></div></nav><div class=container><div class=aa-blogpost><div class=aa-blogpost-header><div class=aa-blogpost-header_title><a href=/blog/2020-02-24-azure-functions-service-bus-limits/>Límites en azure functions para procesos de larga duración</a></div><div class=aa-blogpost-header_date>24-02-2020</div></div></div><div class=aa-blogpost-content><p>Estas últimas semanas he tenido que implementar ciertas mejoras en un proyecto. El objetivo era muy simple, conectar el proyecto a una aplicación de datawarehousing existente, y de forma externa, realizar agregados y luego aplicar cierto procesamiento para un servicio en particular.</p><p>Además había una serie de requisitos extras:</p><ol><li>El procesamiento iba a ser reutilizado por otro proyecto. Y requería comprimir y cifrar archivos grandes.</li><li>La primera parte tenía que simplemente,</li><li>Había una deadline muy cercana para este proyecto.</li></ol><p>Con todas estas limitaciones, la solución propuesta fue esta:</p><img src=/images/function-bus.png class=img-responsive><p>Una azure function cuyo trigger sería un service bus que viene desde el datawarehouse. Esta function sería la responsable de consumir el mensaje y mandar la query.
Después, llamaría a otra function que continuaría con el resto de proceso compartido, pero que queda fuera de scope en este artículo.</p><p>Tras hacer una serie de pruebas me encontré con que algunas queries de agregados eran realmente lentas. En principio no debería haber ningún problema, ya que la function era de tipo service plan y el host.json tenía la propiedad de functionTimeout a -1.</p><pre><code>{
    &quot;version&quot;: &quot;2.0&quot;,
    &quot;functionTimeout&quot;: -1
}
</code></pre><p>Sin embargo, me encontré con otra sorpresa. El peek del mensaje del service bus. Tal como dice la documentación, <a href="https://docs.microsoft.com/th-th/azure/azure-functions/functions-bindings-service-bus-trigger?tabs=csharp#peeklock-behavior">el tiempo máximo que podemos tener un mensaje de service bus marcado como invisible es de 10 minutos</a>. Y esto no es una limitación de la function, sino del service bus en sí. Además, la mayoría de soluciones ya no eran compatibles con functions v2 porque se había cambiado el modelo que exponía el sdk.</p><p>Después de darle vueltas, estuve revisando que pasaba con el caso de los mensajes de un storage. Y aquí fue donde encontre la luz. Aunque la documentación era claramente confusa porque, ojo, el <a href="https://docs.microsoft.com/es-es/azure/azure-functions/functions-bindings-storage-queue?tabs=csharp#host-json">parámetro de visibilityTimeout del host.json representa que el tiempo que el mensaje permanece invisible tras FALLAR una de las ejecuciones</a>.</p><p>Existe dentro del código un visibilityTimeout que realmente representa lo que queremos: El tiempo en el cual el mensaje esta marcado como invisible. Ese código es <a href=https://github.com/Azure/azure-webjobs-sdk/blob/4130350327c6d637d48456222de7e658c6cf729a/src/Microsoft.Azure.WebJobs.Extensions.Storage/Queues/Listeners/QueueListener.cs#L104>este</a>.</p><p>Y como se ve más abajo, <a href=https://github.com/Azure/azure-webjobs-sdk/blob/4130350327c6d637d48456222de7e658c6cf729a/src/Microsoft.Azure.WebJobs.Extensions.Storage/Queues/Listeners/QueueListener.cs#L363>va renovando automáticamente el mensaje, sin límite</a></p><p>Ahora, la nueva implementación ha pasado a ser esta:</p><img src=/images/function-bus-queue.png class=img-responsive><p>Y por ahora, tras las pruebas realizadas. Ha funcionado como se esperaba y ha resuelto la casuística.</p></div></div><div class=aa-navigator><div class=row><div class="col-xs-2 col-lg-3" style=text-align:right></div><div class="col-xs-8 col-lg-6 center"></div><div class="col-xs-2 col-lg-3"><a class="btn-floating btn-large paginate-button" href=https://adrianabreu.github.io/blog/2019-11-09-spark-concepts-basicos/><i class="fa fa-2x fa-arrow-right" aria-hidden=true></i></a></div></div></div></div></div></body></html>