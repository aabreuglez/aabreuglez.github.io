<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="map[]"><title>Notas sobre programación funcional en Scala I</title><meta name=generator content="Hugo 0.69.2"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet type=text/css href=https://adrianabreu.github.io/css/main.css><link rel=stylesheet type=text/css href=https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700,800" rel=stylesheet><!--[if lt IE 9]><script src=https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js></script><script src=https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js></script><![endif]--></head><body><div id=wrap><nav class="navbar navbar-default"><div class=container><div class=navbar-header><a class=navbar-brand href=https://adrianabreu.github.io><i class="fa fa-home"></i></a></div><div id=navbar><ul class="nav navbar-nav navbar-right"><li><a href=/>INICIO</a></li><li><a href=/blog/>BLOG</a></li><li><a href=/knowledge/>KNOWLEDGE</a></li><li><a href=/archive/>ARCHIVE</a></li></ul></div></div></nav><div class=container><div class=aa-blogpost><div class=aa-blogpost-header><div class=aa-blogpost-header_title><a href=/blog/2020-04-07-notes-on-functional-programming-in-scala-i/>Notas sobre programación funcional en Scala I</a></div><div class=aa-blogpost-header_date>06-04-2020</div></div></div><div class=aa-blogpost-content><p>Hace unos días pude comprarme el <a href=https://www.amazon.es/Functional-Programming-Scala-Paul-Chiusano/dp/1617290653>libro de Paul Chiusano y Rúnar Bjarnason: Functional Programming in scala</a> y no puedo estar más contento con él.</p><p>Como ya es costumbre, aprovecho para dejar mis notas sobre el libro en el blog. No se trata de un resumen del mismo sino curiosidades que sé que volveré a consultar en un futuro. Intentaré que no queden post excesivamente largos haciendo un por capítulo. Igualmente, recomiendo a todo el mundo adquirir &ldquo;el libro rojo de Scala&rdquo; y echarle un vistazo.</p><h2 id=getting-started-with-functional-programming>Getting started with functional programming</h2><h3 id=loops-as-functions>Loops as functions</h3><p>La idea de mantener todo como una función es permitir hacer las composiciones y la testabilidad a lo largo del código, para ello se suele crear un función interna llamada <em>loop</em> o <em>go</em> por convenio que se encargará de hacer el bucle.</p><p>Aprovecho para dejar el ejemplo más común de recursividad y así vemos la diferencia de hacerlo como un bucle interno, el factorial.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>def</span> factorial<span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
    <span style=color:#66d9ef>else</span> n <span style=color:#f92672>*</span> factorial<span style=color:#f92672>(</span>n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>)</span>
<span style=color:#f92672>}</span></code></pre></div><p>En cambio, con un bucle interno</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>def</span> factorial<span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>def</span> loop<span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>,</span> acc<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span> acc
        <span style=color:#66d9ef>else</span> loop<span style=color:#f92672>(</span>n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span>n<span style=color:#f92672>*</span>acc<span style=color:#f92672>)</span>
    <span style=color:#f92672>}</span>
    loop<span style=color:#f92672>(</span>n<span style=color:#f92672>,</span><span style=color:#ae81ff>1</span><span style=color:#f92672>)</span>
<span style=color:#f92672>}</span></code></pre></div><p>Como vemos, la función de loop interna se asemeja mucho a un bucle normal. Y la diferencia
con el factorial normal es, que el factorial normal necesita llegar hasta final para resolver la cascada de llamadas mientras que loop se resuelve sus parámetros en cada iteración.</p><p><strong>Tail call optimisation</strong>: Uno de los mayores problemas de la recursividad es que al ser necesario mantener el stack de llamadas de la función para valores muy grandes podemos acabar en un stackoverflow error.
Cuando el compilador detecta que las llamadas recursivas se hacen al final, es capaz de convertirlo en bucles iterativos que no requieren mantener el stack. Si queremos forzar una función como recursiva y que el compilador falle si no lo es podemos usar la anotación <em>tailrec</em>. La verdad es que detectar esto en casos complejos, es realmente dificil y un post muy interesante sobre eso es <a href=http://blog.richdougherty.com/2009/04/tail-calls-tailrec-and-trampolines.html>este</a>.</p><h3 id=higher-order-functions>Higher-order Functions</h3><p>Este concepto siempre me había resultado difícil de entender en el mundo de Redux, pero la verdad es que en Scala es muy intuitivo. Las HoF son functiones que aceptan funciones como parámetros. En Scala es muy intuitivo declarar una función como párametro. Por ejemplo pongamos que queremos validar un &ldquo;predicado&rdquo; para numeros enteros, el tipo del predicado sería Int => Boolean. Y una función de comprobación podría ser:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>def</span> check<span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>,</span> p<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Boolean</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Boolean</span> <span style=color:#f92672>=</span> p<span style=color:#f92672>(</span>n<span style=color:#f92672>)</span></code></pre></div><p><strong>Nota</strong>: Es común encontrarse con nombres de una sola letra como f,g o h para los parámetros de las HoF, esto es porque se supone que la función no sabe nada de lo que hace el parámetros, solo de su tipo.</p><h3 id=anonymous-functions-or-literal-functions>Anonymous functions or literal functions</h3><p>El uso de las HoF se vería bastante limitado si tuviesemos que pasar funciones funciones ya existentes. En base al ejemplo anterior:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>def</span> isPositive<span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Boolean</span> <span style=color:#f92672>=</span> n <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>

<span style=color:#66d9ef>def</span> check<span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>,</span> p<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Boolean</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Boolean</span> <span style=color:#f92672>=</span> p<span style=color:#f92672>(</span>n<span style=color:#f92672>)</span>

check<span style=color:#f92672>(</span><span style=color:#ae81ff>3</span><span style=color:#f92672>,</span> isPositive<span style=color:#f92672>)</span></code></pre></div><p>En Scala podemos definir funciones inline como ahora vamos a ver:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>def</span> check<span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>,</span> p<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Boolean</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Boolean</span> <span style=color:#f92672>=</span> p<span style=color:#f92672>(</span>n<span style=color:#f92672>)</span>

check<span style=color:#f92672>(</span><span style=color:#ae81ff>3</span><span style=color:#f92672>,</span> <span style=color:#f92672>(</span>x<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> x <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span></code></pre></div><p>Este tipo de funciones ya existen en muchos lenguajes, lo curioso es que en Scala lo que se está definiendo por debajo es un object con un método apply. En Scala estos objects con apply se pueden llamar directamente como si fueran métodos. Se <a href=https://www.scala-lang.org/old/node/133.html>explica muy bien en este post</a>.</p><p>Lo he probado en mi máquina, y el resultado no ha sido el esperado. Ha aparecido un tipo nuevo: Lambda. He estado investigando y <a href=https://www.scala-lang.org/news/2.12.0/#lambda-syntax-for-sam-types>desde Scala 2.12 se hace uso de los lambdas de Java</a></p><p>Por ahora, <a href=https://github.com/scala/scala/blob/2.13.x/src/library/scala/Function22.scala>el límite está en 22 parámetros</a>, lo cual debería ser más que suficiente para una función anónima. (Por si acaso, lo he probado y este es el mensaje de error: &ldquo;functions may not have more than 22 parameters, but 25 given&rdquo;)</p><h3 id=partial-application>Partial application</h3><p>Este concepto me resultó bastante difícil de entender, porque se confunde fácilmente con el término currying. Como es más claro, empecemos por el currying consiste en &ldquo;romper&rdquo; las funciones en funciones de un parámetro, por ejemplo, volviendo al método check de antes.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>def</span> check<span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)(</span>p<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Boolean</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Boolean</span> <span style=color:#f92672>=</span> p<span style=color:#f92672>(</span>n<span style=color:#f92672>)</span>

check<span style=color:#f92672>(</span><span style=color:#ae81ff>3</span><span style=color:#f92672>)((</span>x<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> x <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span></code></pre></div><p>Con esto podríamos definir el número en un punto del programa y el predicado en otro. Sin embargo, lo que hace el partial application, es darnos la posibilidad de no usar todos los argumentos a la hora de llamar a la función.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>def</span> check<span style=color:#f92672>(</span>n<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>,</span>p<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Boolean</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Boolean</span> <span style=color:#f92672>=</span> p<span style=color:#f92672>(</span>n<span style=color:#f92672>)</span>

<span style=color:#66d9ef>val</span> f <span style=color:#66d9ef>=</span> check<span style=color:#f92672>(</span><span style=color:#ae81ff>3</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>_:</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Boolean</span><span style=color:#f92672>)</span>
f<span style=color:#f92672>((</span>x<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> x <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span></code></pre></div><p>Con esto estaría cubierto todo lo relacionado con este capítulo para más información sobre este último punto recomiendo <a href=https://www.geeksforgeeks.org/scala-partially-applied-functions/>esta página</a></p></div></div><div class=aa-navigator><div class=row><div class="col-xs-2 col-lg-3" style=text-align:right><a href=https://adrianabreu.github.io/blog/2020-04-27-scala-best-practices-nicolas-rinaudo/><i class="fa fa-2x fa-arrow-left" aria-hidden=true></i></a></div><div class="col-xs-8 col-lg-6 center"></div><div class="col-xs-2 col-lg-3"><a class="btn-floating btn-large paginate-button" href=https://adrianabreu.github.io/blog/2020-02-24-azure-functions-service-bus-limits/><i class="fa fa-2x fa-arrow-right" aria-hidden=true></i></a></div></div></div></div></div></body></html>