<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="map[]"><title>Depurando queries en hive</title><meta name=generator content="Hugo 0.69.2"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet type=text/css href=https://adrianabreu.github.io/css/main.css><link rel=stylesheet type=text/css href=https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700,800" rel=stylesheet><!--[if lt IE 9]><script src=https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js></script><script src=https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js></script><![endif]--></head><body><div id=wrap><nav class="navbar navbar-default"><div class=container><div class=navbar-header><a class=navbar-brand href=https://adrianabreu.github.io><i class="fa fa-home"></i></a></div><div id=navbar><ul class="nav navbar-nav navbar-right"><li><a href=/>INICIO</a></li><li><a href=/blog/>BLOG</a></li><li><a href=/knowledge/>KNOWLEDGE</a></li><li><a href=/archive/>ARCHIVE</a></li></ul></div></div></nav><div class=container><div class=aa-blogpost><div class=aa-blogpost-header><div class=aa-blogpost-header_title><a href=/blog/2020-05-17-depurando-hive-queries/>Depurando queries en hive</a></div><div class=aa-blogpost-header_date>17-05-2019</div></div></div><div class=aa-blogpost-content><p>En la última he podido ver qué pasa cuando el volumen de datos aumenta de forma exponencial, una query que funcionaba en un tiempo razonable para un volumen considerable ha empezado a fallar a pesar de los reintentos.</p><p>¿El origen?</p><pre><code>Status: Failed 19/05/21 01:05:30 [main]: ERROR SessionState: Status: Failed Vertex failed, vertexName=Map 10, vertexId=vertex_1558386441915_0035_1_01, diagnostics=[Task failed, taskId=task_1558386441915_0035_1_01_000002, diagnostics=[TaskAttempt 0 failed, info=[Error: Failure while running task:java.lang.RuntimeException: java.lang.OutOfMemoryError: Java heap space 
</code></pre><p>Esto se traduce en que uno de los vértices, ha tenido que mover demasiados datos y hemos acabado sin memoria.</p><p>Tras hacer muchas pruebas, revisar el plan de ejecución (a través del Dag View, usando el <code>EXPLAIN EXTENDED</code>), etcétera.
He acabado delante de una frase muy genérica: “Tienes que comprender tus datos”.</p><p>Aunque en un principio parece la portada de un folleto barato de autoestima, es realmente acertado. ¿Por qué? Tenemos que revisar dos partes: El data skew, y como hace hive los joins.</p><h2 id=data-skewness>Data skewness:</h2><p>Cuando trabajamos con datos, lo que esperamos es que se distribuyan siguiendo la forma de una función normal, una campana de Gauss.</p><img src=/images/gaussbell.png class=img-responsive><p>Sin embargo, el término de data skewness hace referencia a cuando los datos tienen “una cola”. En vez de estar en una media normal hay un cúmulo de datos a la izquierda o a la derecha.</p><img src=/images/skew.png class=img-responsive><p>Este concepto se puede encontrar formalmente en la estadística, para más información podéis revisar <a href=aqu%C3%AD>https://www.investopedia.com/terms/s/skewness.asp</a>.</p><h2 id=como-hive-hace-los-joins>Como hive hace los joins</h2><p>Es importante tener claro como hive hace las joins al trabajar con datos.</p><p>Pongamos que queremos unir dos tablas A y B.</p><p><code>SELECT a.ID FROM A INNER JOIN B ON A.ID = B.ID</code></p><p>Lo que va psará es que las filas se distribuirán a lo largo de los reducers. Todas las id1 irán a un reducer, las id2 a otro, las id3 a otro etcétera.</p><h2 id=uniendo-conceptos>Uniendo conceptos</h2><p>Pongamos que tenemos un sistema de datawarehouse para el sector del retail. Donde un usuario registrado puede identificarse en caja para conseguir descuentos.</p><p>Si intentamos unir el volumen de tickets con los usuarios, ¿qué pasará?</p><pre><code>SELECT * 
FROM dbo.tickets t 
LEFT JOIN usuarios u
ON t.userid = u.id 
</code></pre><p>Si la tabla de usuarios es lo suficientemente grande, hive no hará un map join sino un join normal, que distribuirá a lo largo de n tareas.</p><p>¿Qué pasaría según lo que hemos dicho antes?</p><p>A la hora de ordenar, estamos ante un caso de data skew.</p><p>Un usuario medio tendrá n compras, y con excepciones estará a una distancia relativamente cercana de la media.</p><p>Sin embargo, a menos de que el sistema sea un éxito, lo más probable es que el número de tickets con userid a nulo sea enorme y estos acaben todos en la misma tarea, desembocando en un outofmemory.</p><h2 id=solución>Solución</h2><p>¿Ahora que tenemos el problema, como solucionamos esto?</p><p>La solución es realmente sencilla si conocemos nuestros datos, basta con unir solo la parte que nos interesa.</p><pre><code>SELECT *  

FROM ( 

    SELECT * 
    FROM dbo.tickets t 
    LEFT JOIN usuarios u 
    ON t.userid is not null AND t.userid = u.id 

UNION ALL 

    SELECT * 
    FROM dbo.tickets t 
    WHERE t.userid IS NULL 
) p
</code></pre><p>Con este simple union forzamos que los tickets con id a nulo se distribuyan a lo largo de otro reducer (puesto que tiene que crear uno para aplicar el filtro) y el join con usuario quede normalizado a lo largo del volumen.</p></div></div><div class=aa-navigator><div class=row><div class="col-xs-2 col-lg-3" style=text-align:right><a href=https://adrianabreu.github.io/blog/2019-09-26-correlated-subqueries/><i class="fa fa-2x fa-arrow-left" aria-hidden=true></i></a></div><div class="col-xs-8 col-lg-6 center"></div><div class="col-xs-2 col-lg-3"><a class="btn-floating btn-large paginate-button" href=https://adrianabreu.github.io/blog/2020-04-27-scala-best-practices-nicolas-rinaudo/><i class="fa fa-2x fa-arrow-right" aria-hidden=true></i></a></div></div></div></div></div></body></html>