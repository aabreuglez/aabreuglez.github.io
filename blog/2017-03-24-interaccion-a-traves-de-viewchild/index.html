<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="map[]"><title>Interacción a través de ViewChild en Angular</title><meta name=generator content="Hugo 0.69.2"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet type=text/css href=https://adrianabreu.github.io/css/main.css><link rel=stylesheet type=text/css href=https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700,800" rel=stylesheet><!--[if lt IE 9]><script src=https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js></script><script src=https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js></script><![endif]--></head><body><div id=wrap><nav class="navbar navbar-default"><div class=container><div class=navbar-header><a class=navbar-brand href=https://adrianabreu.github.io><i class="fa fa-home"></i></a></div><div id=navbar><ul class="nav navbar-nav navbar-right"><li><a href=/>INICIO</a></li><li><a href=/blog/>BLOG</a></li><li><a href=/knowledge/>KNOWLEDGE</a></li><li><a href=/archive/>ARCHIVE</a></li></ul></div></div></nav><div class=container><div class=aa-blogpost><div class=aa-blogpost-header><div class=aa-blogpost-header_title><a href=/blog/2017-03-24-interaccion-a-traves-de-viewchild/>Interacción a través de ViewChild en Angular</a></div><div class=aa-blogpost-header_date>24-03-2017</div></div></div><div class=aa-blogpost-content><p>Hoy me he encontrado con una situación peculiar en un código. Aunque considero que quizás como está realizada la tarea no sea la mejor opción, creo que es un buen ejemplo para entender algunos conceptos de Angular.</p><p>Partiendo de una aplicaicón muy básica donde tenemos dos componentes: <strong>AppComponent</strong> y <strong>ChildComponent</strong>, vamos a renderizar dinámicamente el componente hijo desde el componente padre y ejecutar una serie de acciones.</p><p>Empecemos por el componente padre:</p><pre><code>&lt;h1&gt;
  {{title}}
&lt;/h1&gt;

&lt;button type=&quot;button&quot; (click)=&quot;renderChildAndDoChildStuff()&quot;&gt;Render the child!&lt;/button&gt;
&lt;child *ngIf=&quot;timeToRenderChild&quot;&gt;&lt;/child&gt;
</code></pre><p><strong>app.component.ts</strong></p><pre><code>import { Component, ViewChild } from '@angular/core';
import { ChildComponent } from './child/child.component';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'app works!';

  @ViewChild(ChildComponent)
  private childComponent: ChildComponent;

  private timeToRenderChild: boolean;

  constructor() {
    this.timeToRenderChild = false;
  }

  renderChildAndDoChildStuff() {
    this.timeToRenderChild = true;
    this.childComponent.doStuff();
  }
}

</code></pre><p><strong>app.component.html</strong></p><p>Varios detalles:</p><ol><li><p>La directiva ngIf hace que hasta que no se cumpla la condición no empiece el renderizado del componente hijo.</p></li><li><p>El decorator @ViewChild permite que un componente padre acceda a las propiedades de un componente hijo.</p></li></ol><p>La funcion doStuff no hace más que modificar un valor de texto en el componente hijo. ¿Que pasa cuando hacemos click en el botón?</p><img src=/images/error-viewchild-lifecycle.png class=img-responsive><p>Tenemos un error, que nos dice que nuestro componente aún está en estado undefined.
¿Como podemos saber que nuestro componente está listo?</p><p>Aquí entran en juego los <a href=https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html>lifecycle hooks</a>. Si utlizamos OnInit, ya estará nuestro componente resuelto. Pero, y aquí el quid del post, aún falta una cosa. Y es que el componente padre sepa que el hijo ha terminado de instanciarse. En un principio notificar una acción de un componente hijo a un componente padre es tan sencillo como usar un evento.</p><p>Pero esto no es suficiente: Cuando el componente hijo ya esté creado será demasiado tarde como para modificar el componente padre en el mismo ciclo (debido a la estructura en árbol del detector de cambios), por tanto, es necesario esperar un tiempo, y esto se consigue utilizando por ejemplo un setTimeOut.</p><pre><code>setTimeout(() =&gt; this.childComponent.doStuff(), 0);
</code></pre><p>Para ver el código del post:
<a href=https://github.com/adrianabreu/angular_viewchild_lifecycle>https://github.com/adrianabreu/angular_viewchild_lifecycle</a></p><p>Para más información:
<a href=https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html#smarter-change-detection>https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html#smarter-change-detection</a></p></div></div><div class=aa-navigator><div class=row><div class="col-xs-2 col-lg-3" style=text-align:right><a href=https://adrianabreu.github.io/blog/2017-04-08-capas-en-el-backend/><i class="fa fa-2x fa-arrow-left" aria-hidden=true></i></a></div><div class="col-xs-8 col-lg-6 center"></div><div class="col-xs-2 col-lg-3"><a class="btn-floating btn-large paginate-button" href=https://adrianabreu.github.io/blog/2017-03-12-como-construir-un-portfolio/><i class="fa fa-2x fa-arrow-right" aria-hidden=true></i></a></div></div></div></div></div></body></html>