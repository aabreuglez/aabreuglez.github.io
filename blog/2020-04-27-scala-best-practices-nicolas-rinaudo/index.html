<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="map[]"><title>Scala best practices notes</title><meta name=generator content="Hugo 0.69.2"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet type=text/css href=https://adrianabreu.github.io/css/main.css><link rel=stylesheet type=text/css href=https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700,800" rel=stylesheet><!--[if lt IE 9]><script src=https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js></script><script src=https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js></script><![endif]--></head><body><div id=wrap><nav class="navbar navbar-default"><div class=container><div class=navbar-header><a class=navbar-brand href=https://adrianabreu.github.io><i class="fa fa-home"></i></a></div><div id=navbar><ul class="nav navbar-nav navbar-right"><li><a href=/>INICIO</a></li><li><a href=/blog/>BLOG</a></li><li><a href=/knowledge/>KNOWLEDGE</a></li><li><a href=/archive/>ARCHIVE</a></li></ul></div></div></nav><div class=container><div class=aa-blogpost><div class=aa-blogpost-header><div class=aa-blogpost-header_title><a href=/blog/2020-04-27-scala-best-practices-nicolas-rinaudo/>Scala best practices notes</a></div><div class=aa-blogpost-header_date>27-04-2020</div></div></div><div class=aa-blogpost-content><p>He aprovechado estos días de cuarentena para revisar algunos de los &ldquo;huecos&rdquo; de conocimiento que tenía en Scala. Una de las charlas que he podido ver es esta: <a href="https://www.youtube.com/watch?v=DGa58FfiMqc">Scala best practices I wish someone&rsquo;d told me about - Nicolas Rinaudo</a></p><p>Por supuesto siempre recomiendo ver la charla, pero he querido condensar (aún más) ese conocimiento en este post, insisto, es amena y muy interesante, muchos de los puntos que se definen en la charla no se han explicado porque la mayoría se resuelven en dotty y aunque</p><h2 id=type-annotation>Type annotation</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>def</span> asOption<span style=color:#f92672>[</span><span style=color:#66d9ef>A</span><span style=color:#f92672>](</span>a<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>A</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Some</span><span style=color:#f92672>(</span>a<span style=color:#f92672>)</span></code></pre></div><p>Un método como este, si va a ser público, debería tener especificado el tipo que devuelve, porque el compilador, en vez de inferir que es un Option[A] va a inferior que su tipo es Some[A] y aunque no es gran cosa esto (Some es un subtype de Option) un cambio menor puede romper el contrato de una librería.</p><h2 id=sealed-traits>Sealed traits</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Foo</span>

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Bar</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Foo</span></code></pre></div><p>Cuando definimos un sealed trait específicamos que todo subtipo directo estará especificado en el mismo fichero. El problema es que Bar es una class, y se puede heredar desde cualquier otro lugar, lo cual puede dar un comportamiento inesperado. La solución a esto es hacer que Bar sea final o sealed.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Foo</span>

<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Bar</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Foo</span></code></pre></div><p>Lo mejor es hacer esto por defecto, y si hay algún motivo cambiarlo.</p><h2 id=algebraic-data-types>Algebraic Data Types</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Status</span> 

<span style=color:#66d9ef>object</span> <span style=color:#a6e22e>Status</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>object</span> <span style=color:#a6e22e>Ok</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Status</span>
    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>object</span> <span style=color:#a6e22e>Nok</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Status</span>
<span style=color:#f92672>}</span></code></pre></div><p>Este código parecer perfectamente razonable, el problema es que si creamos una lista</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#a6e22e>List</span><span style=color:#f92672>(</span><span style=color:#a6e22e>Status</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Ok</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>Status</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Nok</span><span style=color:#f92672>)</span></code></pre></div><p>En vez de obtener el tipo List[Status] obtenemos un tipo mucho más complejo, y este tipo ocurre porque ambos miembros son case object, asi que cuando el compilador busca los tipos más comunes, encuentra todos esos tipos. La solución sería hacer que el trait herede de ambos, para ser el tipo más cercano en la jerarquía. Así evitamos que detalles de implementación lleguen al usuario.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Status</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Product</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Serializable</span>

<span style=color:#66d9ef>object</span> <span style=color:#a6e22e>Status</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>object</span> <span style=color:#a6e22e>Ok</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Status</span>
    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>object</span> <span style=color:#a6e22e>Nok</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Status</span>
<span style=color:#f92672>}</span></code></pre></div><h2 id=case-classes>Case classes</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>case</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span><span style=color:#f92672>(</span>i<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span>

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Bar</span><span style=color:#f92672>(</span>i<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>,</span> s<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Foo</span><span style=color:#f92672>(</span>i<span style=color:#f92672>)</span>

<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Bar</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;foo&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Bar</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;bar&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>//</span> <span style=color:#66d9ef>true</span></code></pre></div><p>Este ejemplo describe un comportamiento muy muy interesante y que está relacionado con que las case classes deben ser final. Al crear una case class se sobreescribe el método equals y esto hace que la clase Bar que exiente de Foo, tenga el método equals de la case class Foo, haciendo que cuando comparemos Bar realmente estemos comaprando Foo.</p><h2 id=exceptions>Exceptions</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>def</span> parseInt<span style=color:#f92672>(</span>str<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>=</span> str<span style=color:#f92672>.</span>toInt</code></pre></div><p>Las excepciones no son referential transparent, con lo cual no debemos lanzarlas. Si es posible se recomienda utilizar las clases Either (para computaciones que pueden fallar) Option (para tratar valores que pueden no existir) y si hay que utilizar excepciones, utilizar Try.</p><h2 id=errors>Errors</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>DbError</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Exceptions</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Product</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>Serializable</span>

<span style=color:#66d9ef>object</span> <span style=color:#a6e22e>DbError</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>object</span> <span style=color:#a6e22e>InvalidSql</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>DbError</span>
    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>object</span> <span style=color:#a6e22e>ConnectionLost</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>DbError</span>
<span style=color:#f92672>}</span></code></pre></div><p>Aunque se desrecomienda lanzar excepciones, no se desrecomienda usarlas. Si queremos tipar un error, lo mejor que podemos hacer es extender la clase Exception. De esta manera podremos utilizar el tipo en Try y en Future.</p><h2 id=return>Return</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>def</span> foo<span style=color:#f92672>(</span>is<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>List</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Int</span><span style=color:#f92672>])</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>List</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Int</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span>
is<span style=color:#f92672>.</span>map<span style=color:#f92672>(</span>n <span style=color:#66d9ef>=&gt;</span> <span style=color:#66d9ef>return</span> n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>)</span></code></pre></div><p>Este ejemplo es realmente complicado de enseñar, se desrecomienda usar return proqeu genera error a la hora de inferir los tipos en el compilador, el codigo de arriba genera un extraño bucle de List[Int] -> Int -> List[Nothing] -> Int -> List[Nothing] -> Int&mldr;</p><p>Estos han sido los detalles que más me han gustado y parecido relevantes de la charla, espero que alguien lo encuentro tan útil como yo :)</p></div></div><div class=aa-navigator><div class=row><div class="col-xs-2 col-lg-3" style=text-align:right></div><div class="col-xs-8 col-lg-6 center"></div><div class="col-xs-2 col-lg-3"><a class="btn-floating btn-large paginate-button" href=https://adrianabreu.github.io/blog/2020-04-07-notes-on-functional-programming-in-scala-i/><i class="fa fa-2x fa-arrow-right" aria-hidden=true></i></a></div></div></div></div></div></body></html>